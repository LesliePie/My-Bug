## 适配器模式
### 动机
> 把客户类的请求转化为对适配者的响应接口调用。也就是说:当客户类调用适配器的方法的时候，在适配器类的内部将调用适配者类的方法，而这个过程对客户类来说是透明的，客户类并不直接访问适配者类
   适配器可以使由于接口不兼容而不能交互的类可以一起工作
### 结构
> * 类适配:
>> * Target: 目标抽象类
>> * Adaptor: 适配器类
>> * Adaptee: 适配者类
> * 对象适配
>> * Target: 目标抽象
>> * Adaptee: 适配者
>> * Adaptor: 适配器
### 优点
> *  将目标类和适配者类进行了解耦
> * 增加了类的透明性和复用性
> * 灵活性和扩展性都还不错,可以在不修改代码的情况下增加新的适配器
### 适用环境
> * 系统需要使用现有的类，而这些类的接口不太符合系统的需要
> * 想要建立一个可以重复使用的类，用于彼此之间没有关系的类，包括可能在将来引进的类一起进行工作
### 使用例子
> * JDBC jdbc给出客户端通用的抽象接口，每一个数据库的引擎的JDBC驱动软件都是介于JDBC接口和数据库引擎接口之间的一个适配器软件
> * spring AOP 对 BeforeAdvice AfterAdvice ThrowAdvice借助适配器模式来进行实现
### 扩展
> * 默认适配器
>> * 实现:设计一个抽象类实现接口，并为该接口的每个方法提供一个默认的实现(空方法)，抽象类的子类选择性的覆盖父类的方法来实现需求
>> * 使用环境: 适用于一个接口不想使用其所有方法的情况下，称为单接口适配器模式
> * 双向适配
>> * 在适配器中包含对目标类和适配器者类的引用，适配者可以通过它调用目标类中的方法。目标类也可以通过它调用适配者类中的方法，那么该适配器就是双向适配器