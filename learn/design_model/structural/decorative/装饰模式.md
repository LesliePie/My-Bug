## 装饰模式
### 动机
> * 对客户透明的方式动态地给对象附加上更多的责任，可以在不需要创造更多子类的情况下，将对象的功能加以扩展
### 定义
> * 动态地给对象增加一些额外的职责，这样比生成子类更加的灵活，其别名也称为包装器，它是一种对象结构型模式
### 模式分析
> * 不会破坏类的封装性，而且继承耦合性比较大，无法在程序运行时动态扩展。在开发阶段，关联关系虽然不会比继承关系减少代码量，但是在维护的时候，由于比较松耦合，因此使得系统更加容易维护
其缺点就是比继承关系要创建更多的对象
> * 比继承更加灵活，它以对客户透明的方式动态地给对象附加更多的责任。可以在不需要子类的情况下，将对象的功能加以扩展
### 结构
> * 抽象装饰 Transform 
> * 具体构建 Car 变形金刚是个车
> * 抽象装饰 Change 
> * 具体装饰 Airplane Robot
### 优点
> * 和继承相比都是可以进行对象的功能扩展，但是装饰模式比继承有更多的灵活性
> * 可以通过动态的方式扩展对象的功能，通过配置文件选择不同的装饰器，实现不同的行为
> * 通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合
> * 具体构建类和 具体装饰类可以灵活变化
### 缺点
> * 会产生很多小对象，这些对象的区别在于他们相互连接的方式不同，而不是类的属性不同，同时还会产生很多的具体装饰类，增加了系统的复杂度，加大学习和理解成本
> * 装饰模式比继承更加容易出错，排错困难
### 适用环境
> * 不影响其他对象的情况下，以动态，透明的方式给单个对象添加职责
> * 需要动态的给一个对象增加功能，这些功能也可以动态的被撤销
>  * 当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护的时候
### 使用案例
> * java IO 
