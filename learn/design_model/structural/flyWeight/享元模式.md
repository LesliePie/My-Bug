## 享元模式
### 模式动机
> * 当系统对象过多的时候将,会导致运行代价过高，带来性能下降等相关问题
> * 享元模式即是通过共享技术相同或者相似的对象的重用
> * 可以共享的相同内容称为内部状态，而那些需要外部环境来设置的不能共享的内容称为外部状态
> * 享元模式通常会出现工厂模式，需要创建一个享元工厂来复杂维护一个享元池用于存储有相同内部状态的享元对象
> * 享元对象一般都是设置为较小的对象，他所包含的内部状态较少，这种对象也被称为细粒度对象。享元模式的目的就是通过共享技术来实现大量细粒度对象的复用
### 模式定义
> * 运用共享技术有效地支持大量细粒度对象的复用，系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元对象要求共享的对象是细粒度对象。他又称为轻量级模式，是对象结构型模式
### 模式分析
> * 享元模式是一个考虑系统性能的设计模式，通过享元模式可以节约内存空间，提高系统性能
> * 其核心在于享元工厂类；享元工厂类的的作用在于提供一个用于储存享元对象的享元池，用户需要对象时，先从享元池中进行获取，如果享元对象不存在，那么就创建一个返回给用户，并在享元池中保存该新增对象
> * 其关键在于区分内部状态和外部状态
>> * 内部状态是存储在享元对象内部，不会因为环境的改变而改变
>> * 外部状态会因为环境的变化而变化，不可以共享的状态
### 结构
> * 享元工厂 DeviceFactory
> * 抽象享元类 NetworkDevice
> * 具体享元类 Switch,Hub
> * 非共享具体享元类 Port
### 优点
> * 减少内存中对象数量
> * 享元对象可以在不同环境中被共享
### 缺点
> * 因为要分离内部状态和外部状态，所以整个结构更加复杂
> * 为了使对象共享，需要将享元对象的状态外部化，而读取外部状态使得运行时间变长
### 适用环境
> * 一个系统有大量相同或者相似对象
> * 大部分状态可以外部化
> * 多次重复适用享元对象时才值得使用享元模式
### 应用案例
> * JDK String 即是所谓常量池
### 模式扩展
> * 单纯享元模式，即是所有享元对象都是可以共享的
> * 复合享元模式