## 外观模式
### 动机
> * 用户只需要与外观角色交互，用户与子系统之间的复杂关系由外观角色来实现，从而降低了角色的耦合度
### 定义
> * 外部与一个子系统的通信必须由一个统一的外观对象进行，为子系统的一组接口提供一个一致的界面，外观模式提供了一个高层接口，这个接口使得子系统更加容易使用。外观模式又称为门面模式
### 模式分析
> * 在软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性。一个常见的设计目标就是使得子系统间的通信和依赖关系达到最小，达到该目标的途径就是引入一个外观对象，它为子系统的访问提供了一个简单而又单一的入口
> * 通过引入一个新的外观类可以降低原有系统的复杂度，同时降低了客户类与子系统类的耦合度
> * 要求一个子系统的外部与内部的通信通过一个统一的外观对象进行，外观类客户端与子系统的内部复杂性分割开，使得客户端只需要和外观对象打交道，而不需要与子系统内部的很多对象打交道
> * 目的是降低系统的复杂程度
> * 同时也是提高了客户端使用的便捷性
### 结构
> * 外观角色 GeneralSwitchFacade,即是本例中的总开关
> * 子系统 AirConditioner,Light,Fan,Television等家电
### 优点
> * 对客户屏蔽了子系统的组件，减少客户处理对象数目并使得子系统使用起来更加容易
> * 实现了子系统和客户之间的松耦合关系
> * 降低了大型软件系统中编译依赖性，简化了系统在不同平台之间的移植过程
> * 只是提供了一个访问子系统的统一入口，并不影响客户访问子系统类
### 缺点
> * 不能很好地限制客户使用子系统类
> * 在不影响抽象外观类的情况下，增加了子系统可能需要修改外观类或客户端的源代码，违背了 _开闭原则_
### 适用环境
> * 当要为一个复杂子系统提供一个简单接口时可以使用外观模式
> * 客户程序与多个子系统之间存在很大的依赖性
> * 在层次化结构中，可以使用外观模式定义系统的每一层的入口，层与层之间不直接产生联系，而是通过外观类建立联系，降低层之间的耦合度
### 使用案例
> * jdbc 操作数据库
> * Session外观模式
### 模式扩展
> * 通常的外观模式只有一个外观类，通常设置为单例。其实可以设置多个外观类，每个外观类都负责和一些特定的子系统进行交互
> * 不能通过继承一个外观类在子系统中加入新的行为
> * 引入抽象外观类来解决子系统改变带来的影响